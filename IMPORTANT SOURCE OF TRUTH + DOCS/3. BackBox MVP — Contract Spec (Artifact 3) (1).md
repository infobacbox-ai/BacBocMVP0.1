# **BackBox MVP — Contract Spec (Artifact 3\)**

Version: v0.4 (CANON)  
Date: 2026-01-23  
Owner: PO/Dev

Ce document définit **le contrat backend** (DB \+ API \+ invariants serveur) de BackBox MVP.

**Règle d’or** : toute règle “produit” ou “edge-case” vit ici (ou dans Acceptance Tests). Le prototype Figma ne fait que **référencer** ces règles.

---

## **0\) Lexique (termes & conventions)**

### **0.1 Entitlements (droit global)**

* **entitlement\_status**: `none | trial_one_run | paid`  
  * `none` : pas d’abonnement actif **et** essai non consommé.  
  * `trial_one_run` : essai consommé (un projet trial existe) **ou** essai en cours.  
  * `paid` : abonnement actif.

Important : **ne jamais utiliser** `trial` comme valeur d’entitlement. `trial` n’existe que comme **mode de projet**.

### **0.2 Access state (dérivé pour l’UI)**

* **accessState**: `NONE | TRIAL_AVAILABLE | TRIAL_ACTIVE | PAID`  
  * `NONE` : non connecté.  
  * `TRIAL_AVAILABLE` : connecté, non paid, essai non consommé.  
  * `TRIAL_ACTIVE` : connecté, non paid, projet trial existe.  
  * `PAID` : abonnement actif.

### **0.3 Objets**

* **project mode**: `trial | paid`  
* **pillar**: `p1 | p2 | p3 | p4`  
* **mini-recap**: feedback IA après un pilier.  
* **final-recap**: synthèse finale P1–P4.

### **0.4 Normes**

* Le serveur fait foi (UI \= reflet).  
* “MUST” \= obligatoire ; “SHOULD” \= recommandé.

---

## **1\) Règles canoniques (IDs stables)**

### **RULE-TRIAL-01 — One-run trial (1 seul projet)**

* Un user **non-paid** ne peut avoir **qu’un seul** projet en mode `trial`.  
* Le trial est **consommé** au moment de `backbox.startTrialProject()` (soumission du texte sur `/backbox/start`).

### **RULE-TRIAL-02 — NO DELETE RESET (anti-loophole)**

* `user_trial_one_run.trialProjectId` et `consumedAt` ne redeviennent **jamais** `null`.  
* Même si un projet trial est supprimé (future API / action manuelle), cela **ne réactive jamais** l’essai.

### **RULE-AI-01 — Pas de fallback “Continuer sans IA”**

* Aucun chemin “continuer sans IA” pour obtenir des mini-récaps ou le récap final.

### **RULE-AI-02 — Retry UI (1 retry max)**

* **Chaque appel API** `generateMiniRecap` / `generateFinalRecap` \= **1 tentative** côté serveur.  
* L’UI peut proposer **1 seul** “Réessayer” (donc 2 tentatives max au total côté UX).  
* Après 2 échecs (1 tentative \+ 1 retry), l’UI affiche “IA indisponible” et propose uniquement :  
  * “Réessayer plus tard”  
  * “Retour au pilier”

### **RULE-QUOTA-01 — Quota trial: 2 évaluations par pilier**

* Sur un projet `mode=trial`, l’action **Évaluer / Améliorer** est limitée à **2 succès persistés par pilier**.  
* Une panne IA **ne consomme pas** le quota.

### **RULE-RATE-01 — Rate limit global: 10 évaluations / heure / user**

* S’applique à `generateMiniRecap` et `generateFinalRecap`.  
* **Compteur \= tentatives**, succès **et** échecs, y compris les retries UI.

### **RULE-LOCK-01 — Dédup “évaluation en cours” (best effort, serveur)**

* Deux générations simultanées sur le même `(userId, projectId, pillar/kind)` MUST être rejetées.  
* L’UI désactive le bouton pendant le chargement ; le serveur protège aussi (lock TTL).

### **RULE-EXPORT-01 — Export autorisé uniquement si finalRecap existe**

* Export (HTML/Print) autorisé en trial et paid **uniquement si** `backbox_finalrecap` existe.  
* Sinon : **409 `FINAL_REQUIRED`**.

---

## **2\) Modèle de données (DB)**

Supastarter gère déjà `user`, `subscription`, auth. BackBox ajoute ses tables.

### **2.1 Tables**

#### **backbox\_project**

* `id: uuid`  
* `userId: uuid` (owner)  
* `title?: string`  
* `sourceText: text`  
* `sourceMeta?: json`  
* `mode: 'trial' | 'paid'`  
* `currentStep: 'p1'|'p2'|'p3'|'p4'|'final'`  
* `createdAt, updatedAt`

**Indexes**

* `index(userId, updatedAt)`

#### **backbox\_answer**

* `id: uuid`  
* `projectId: uuid`  
* `pillar: 'p1'|'p2'|'p3'|'p4'`  
* `fieldKey: string`  
* `content: text | json`  
* `createdAt, updatedAt`

**Contraintes**

* `unique(projectId, pillar, fieldKey)` (upsert idempotent)

**MVP default**

* `fieldKey = 'main'` pour chaque pilier.

#### **backbox\_minirecap**

* `id: uuid`  
* `projectId: uuid`  
* `pillar: 'p1'|'p2'|'p3'|'p4'`  
* `inputSnapshot: json`  
* `output: json` (cf. §6)  
* `score?: number`  
* `createdAt, updatedAt`

**Contraintes**

* `unique(projectId, pillar)` (upsert)

#### **backbox\_finalrecap**

* `id: uuid`  
* `projectId: uuid` (unique)  
* `inputSnapshot: json`  
* `output: json` (cf. §6)  
* `createdAt, updatedAt`

**Contraintes**

* `unique(projectId)`

#### **user\_trial\_one\_run**

* `userId: uuid` (unique)  
* `trialProjectId: uuid | null` (fixé une fois)  
* `consumedAt: timestamp | null` (fixé une fois)  
* `evalCounts: json` ex: `{ "p1": 1, "p2": 2, "p3": 0, "p4": 1 }`  
* `notes?: text` (optionnel)

**Contraintes**

* `unique(userId)`  
* `consumedAt` ne redevient jamais `null` (RULE-TRIAL-02)

#### **ai\_usage\_event (audit \+ fallback rate-limit)**

* `id: uuid`  
* `userId: uuid`  
* `projectId?: uuid`  
* `pillar?: 'p1'|'p2'|'p3'|'p4'`  
* `kind: 'minirecap' | 'finalrecap'`  
* `createdAt: timestamp`  
* `tokensIn?: number, tokensOut?: number`  
* `latencyMs?: number`  
* `errorCode?: string`

**Indexes**

* `index(userId, createdAt)`  
* `index(projectId, createdAt)`

---

## **3\) Accès & autorisations (serveur fait foi)**

### **3.1 Calcul entitlement\_status et accessState**

* `paid` si abonnement actif (source Supastarter / Stripe).  
* sinon `trial_one_run` si `user_trial_one_run.trialProjectId != null`.  
* sinon `none`.  
* `accessState = NONE` si non-auth.  
* `accessState = PAID` si entitlement `paid`.  
* `accessState = TRIAL_ACTIVE` si entitlement `trial_one_run`.  
* `accessState = TRIAL_AVAILABLE` si entitlement `none`.

### **3.2 Matrice d’autorisations (actionnelle)**

| Action | PAID | TRIAL\_AVAILABLE | TRIAL\_ACTIVE | NONE |
| ----- | ----- | ----- | ----- | ----- |
| startTrialProject | ❌ | ✅ | ❌ | ❌ |
| createPaidProject | ✅ | ❌ | ❌ | ❌ |
| listProjects / getProject | ✅ | ✅ | ✅ | ❌ |
| saveAnswer | ✅ | ❌ | ✅ (uniquement sur trialProjectId) | ❌ |
| generateMiniRecap | ✅ | ❌ | ✅ (trialProjectId \+ quota \+ rate-limit) | ❌ |
| generateFinalRecap | ✅ | ❌ | ✅ (trialProjectId \+ rate-limit) | ❌ |
| exportHtml | ✅ | ❌ | ✅ (trialProjectId \+ finalRecap requis) | ❌ |

**Email verification**

* Toute action `start/create/save/generate/export` MUST refuser si email non vérifié → `403 FORBIDDEN`.

**Note “ex-paid” (MVP simple)**

* Si l’abonnement n’est plus actif, on revient à la logique non-paid :  
  * write/IA/export autorisés uniquement sur le projet trial (si présent).  
  * les autres projets restent consultables (read), mais actions sensibles refusées.

---

## **4\) Contrat d’erreurs (HTTP \+ errorCode)**

### **4.1 Format canon**

type ApiError \= {  
  status: 400|401|403|404|409|429|500  
  errorCode:  
    | 'VALIDATION\_ERROR'  
    | 'UNAUTHENTICATED'  
    | 'FORBIDDEN'  
    | 'NOT\_FOUND'  
    | 'FINAL\_REQUIRED'  
    | 'QUOTA\_REACHED'  
    | 'RATE\_LIMIT'  
    | 'EVALUATION\_IN\_PROGRESS'  
    | 'AI\_UNAVAILABLE'  
    | 'INTERNAL\_ERROR'  
  message: string  
  details?: Record\<string, unknown\>  
}

### **4.2 Mapping canon**

* **400** `VALIDATION_ERROR`  
* **401** `UNAUTHENTICATED`  
* **403** `FORBIDDEN` (ownership, entitlement insuffisant, email non vérifié)  
* **404** `NOT_FOUND`  
* **409** `FINAL_REQUIRED` (export demandé sans finalRecap)  
* **429** `QUOTA_REACHED` | `RATE_LIMIT` | `EVALUATION_IN_PROGRESS`  
* **500** `INTERNAL_ERROR` (par défaut) ou `AI_UNAVAILABLE` (provider down/timeout)

---

## **5\) API oRPC (procédures)**

### **5.1 me.getEntitlements**

**Output**

{  
  entitlement\_status: 'none' | 'trial\_one\_run' | 'paid'  
  accessState: 'NONE'|'TRIAL\_AVAILABLE'|'TRIAL\_ACTIVE'|'PAID'  
  trialProjectId: string | null  
  quotas: { perPillarMax: 2, perPillarUsed?: Record\<'p1'|'p2'|'p3'|'p4', number\> }  
  rateLimit: { perHourMax: 10 }  
}

### **5.2 backbox.startTrialProject**

**Input**

{ sourceText: string, title?: string, sourceMeta?: any }

**Guards**

* auth \+ email verified  
* `accessState === TRIAL_AVAILABLE` sinon 403

**Validation**

* `sourceText.trim().length > 0`  
* `sourceText.length <= 30000`  
* `title?.length <= 120`

**Side effects**

* crée `backbox_project(mode='trial', currentStep='p1', ...)`  
* upsert `user_trial_one_run` : fixe `trialProjectId`, fixe `consumedAt`, init `evalCounts`.

**Output**

{ projectId: string }

### **5.3 backbox.createPaidProject**

**Input** identique.

**Guards**

* auth \+ email verified  
* `entitlement_status === 'paid'` sinon 403

**Output**

{ projectId: string }

### **5.4 backbox.listProjects**

**Guards**

* auth

**Output**

Array\<{ id: string, title?: string, mode: 'trial'|'paid', currentStep: string, updatedAt: string }\>

### **5.5 backbox.getProject**

**Input**

{ projectId: string }

**Guards**

* auth \+ ownership

**Output**

{  
  project: {  
    id: string  
    title?: string  
    sourceText: string  
    mode: 'trial'|'paid'  
    currentStep: 'p1'|'p2'|'p3'|'p4'|'final'  
    updatedAt: string  
  }  
  answers: Array\<{ pillar: 'p1'|'p2'|'p3'|'p4', fieldKey: string, content: any }\>  
  miniRecaps: Array\<{ pillar: 'p1'|'p2'|'p3'|'p4', output: any, score?: number }\>  
  finalRecap: null | { output: any }  
}

### **5.6 backbox.saveAnswer**

**Input**

{ projectId: string, pillar: 'p1'|'p2'|'p3'|'p4', fieldKey: string, content: string | any, step?: 'p1'|'p2'|'p3'|'p4' }

**Guards**

* auth \+ ownership  
* PAID OK  
* TRIAL\_ACTIVE uniquement si `projectId === trialProjectId`

**Validation**

* `fieldKey` non vide  
* si `content` est string: `content.length <= 5000`

**Side effects**

* upsert `backbox_answer`  
* si `step` fourni : update `backbox_project.currentStep = step`  
* update `updatedAt`

**Output**

{ ok: true }

### **5.7 backbox.generateMiniRecap**

**Input**

{ projectId: string, pillar: 'p1'|'p2'|'p3'|'p4' }

**Guards**

* auth \+ ownership \+ email verified  
* PAID OK  
* TRIAL\_ACTIVE uniquement si `projectId === trialProjectId`  
* trial : `evalCounts[pillar] < 2`  
* rate-limit (10/h)  
* lock (EVALUATION\_IN\_PROGRESS)

**Behavior (MUST)**

1. Vérifier quota (trial) \+ rate-limit.  
2. Prendre un lock TTL court (30–60s) par clé `(userId, projectId, pillar)`.  
3. Snapshot \= `{ sourceText, answers[pillar], meta minimal }`.  
4. Appeler l’IA (une tentative serveur).  
5. Sur succès :  
   * upsert `backbox_minirecap(projectId,pillar)`  
   * si trial : incrément **atomique** `evalCounts[pillar] += 1` (uniquement après succès persisté)  
6. Log `ai_usage_event` (succès/erreur) dans tous les cas.

**Errors**

* 429 `QUOTA_REACHED`  
* 429 `RATE_LIMIT`  
* 429 `EVALUATION_IN_PROGRESS`  
* 500 `AI_UNAVAILABLE`

**Output**

{ output: MiniRecapOutput, score?: number }

### **5.8 backbox.generateFinalRecap**

**Input**

{ projectId: string }

**Guards**

* auth \+ ownership \+ email verified  
* PAID OK  
* TRIAL\_ACTIVE uniquement si `projectId === trialProjectId`  
* rate-limit  
* lock `(userId, projectId, 'final')`

**Behavior**

* Assemble `answers` \+ `miniRecaps` (et/ou prompts dédiés) → appel IA.  
* upsert `backbox_finalrecap(projectId)`.  
* log `ai_usage_event(kind='finalrecap')`.

**Output**

{ output: FinalRecapOutput }

### **5.9 backbox.exportHtml**

**Input**

{ projectId: string }

**Guards**

* auth \+ ownership \+ email verified  
* PAID OK  
* TRIAL\_ACTIVE uniquement si `projectId === trialProjectId`  
* MUST exiger `backbox_finalrecap` (RULE-EXPORT-01), sinon 409 `FINAL_REQUIRED`

**Behavior (MVP safe)**

* Génère un HTML minimal (template fixe) en **échappant** toutes les données user.  
* Aucune injection de HTML user “brut”.

**Output**

{ html: string }

---

## **6\) Schémas de sortie (output JSON)**

Simplification MVP : **2 forces / 2 améliorations / 1 next action**.

### **6.1 MiniRecapOutput**

type MiniRecapOutput \= {  
  pillar: 'p1'|'p2'|'p3'|'p4'  
  score?: number // 0..100 (optionnel)  
  strengths: string\[\] // 0..2  
  improvements: string\[\] // 0..2  
  nextAction: string  
}

### **6.2 FinalRecapOutput**

type FinalRecapOutput \= {  
  priorities: string\[\] // 1..3 actions prioritaires  
  perPillar: Record\<'p1'|'p2'|'p3'|'p4', {  
    score?: number  
    strengths: string\[\]  
    improvements: string\[\]  
    nextAction: string  
  }\>  
}

---

## **7\) Rate limit / Quotas / Lock (contrat d’implémentation)**

### **7.1 Rate limit (RULE-RATE-01)**

* Fenêtre: 60 minutes glissantes.  
* Compte: **tentatives** (success \+ fail), mini \+ final.  
* Source de vérité recommandée : Upstash/Redis.  
* Fallback acceptable : `ai_usage_event` count last 60 min.

### **7.2 Quota trial (RULE-QUOTA-01)**

* `evalCounts` vit dans `user_trial_one_run`.  
* Incrément **atomique** et **uniquement après succès persisté**.

### **7.3 Lock “in progress” (RULE-LOCK-01)**

* Clé logique:  
  * `eval_lock:{userId}:{projectId}:{pillar}`  
  * `eval_lock:{userId}:{projectId}:final`  
* TTL recommandé: 30–60s.

---

## **8\) Acceptance tests (GWT)**

### **AT-TRIAL-01 (RULE-TRIAL-01)**

**Given** un user non-paid avec `trialProjectId = null`  
**When** `startTrialProject`  
**Then** un `project(mode=trial)` est créé et `trialProjectId/consumedAt` sont fixés.

### **AT-TRIAL-02 (RULE-TRIAL-01)**

**Given** un user non-paid avec `trialProjectId != null`  
**When** `startTrialProject`  
**Then** 403 `FORBIDDEN`.

### **AT-TRIAL-03 (RULE-TRIAL-02)**

**Given** `consumedAt` non-null  
**When** le projet trial est supprimé (hors MVP)  
**Then** `consumedAt` reste non-null et `startTrialProject` reste interdit.

### **AT-AI-01 (RULE-AI-01)**

**Given** un user  
**When** l’IA est indisponible  
**Then** l’API renvoie 500 `AI_UNAVAILABLE` et il n’existe aucun fallback “continuer sans IA”.

### **AT-QUOTA-01 (RULE-QUOTA-01)**

**Given** un projet trial avec `evalCounts.p2 = 2`  
**When** `generateMiniRecap(p2)`  
**Then** 429 `QUOTA_REACHED`.

### **AT-QUOTA-02 (RULE-QUOTA-01)**

**Given** `evalCounts.p1 = 1`  
**When** un appel IA échoue (`AI_UNAVAILABLE`)  
**Then** `evalCounts.p1` reste à 1\.

### **AT-RATE-01 (RULE-RATE-01)**

**Given** 10 tentatives d’évaluation sur 60 minutes (succès ou échec)  
**When** une 11e est demandée  
**Then** 429 `RATE_LIMIT`.

### **AT-LOCK-01 (RULE-LOCK-01)**

**Given** une évaluation déjà en cours sur (projectId, p3)  
**When** une seconde requête arrive avant fin/TTL  
**Then** 429 `EVALUATION_IN_PROGRESS`.

### **AT-EXPORT-01 (RULE-EXPORT-01)**

**Given** `finalRecap` absent  
**When** `exportHtml(projectId)`  
**Then** 409 `FINAL_REQUIRED`.

### **AT-VALID-01**

**Given** `sourceText.length > 30000`  
**When** startTrialProject/createPaidProject  
**Then** 400 `VALIDATION_ERROR`.

### **AT-VALID-02**

**Given** `content.length > 5000`  
**When** saveAnswer  
**Then** 400 `VALIDATION_ERROR`.

---

## **9\) Decision log (ADR-lite)**

* 2026-01-23 — DEC-ENT-01: `entitlement_status = none | trial_one_run | paid` et interdiction d’utiliser `trial` comme entitlement.  
* 2026-01-23 — DEC-AI-RETRY-01: retry piloté par l’UI (1 max), serveur \= 1 tentative par appel.  
* 2026-01-23 — DEC-QUOTA-01: quota trial incrémenté **sur succès persisté** uniquement.  
* 2026-01-23 — DEC-RATE-01: rate-limit global 10/h/user sur mini \+ final, compte les tentatives.  
* 2026-01-23 — DEC-EXPORT-01: export protégé par finalRecap (409 sinon) \+ HTML sécurisé (escape systématique).

